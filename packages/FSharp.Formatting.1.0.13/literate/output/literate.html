<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <!-- 
      The Literate programming for F#
 parameters will be replaced with the 
      document title extracted from the <h1> element or
      file name, if there is no <h1> heading
    -->
    <title>Literate programming for F#
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="My Sample Document">
    <meta name="author" content="Nobuhisa">
    <script src="http://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="http://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="content/style.css" />
    <script src="content/tips.js" type="text/javascript"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://fsharp.org">fsharp.org</a></li>
          <li><a href="https://github.com/Nobuhisa">github page</a></li>
        </ul>
        <h3 class="muted">DocSample</h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          <h1>Literate programming for F#</h1>

<h2>Implementation</h2>

<p>This document is written as a literate F# script file, so the remaining text
is an overview of the implementation. The implementation uses <code>FSharp.Markdown.dll</code>
and <code>FSharp.CodeFormat.dll</code> to colorize F# source &amp; parse Markdown:</p>
<h3>CommandUtils module</h3>

<p>Utilities for parsing commands. Commands can be used in different places. We 
recognize <code>key1=value, key2=value</code> and also <code>key1:value, key2:value</code></p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">module</span> <span class="k">internal</span> <span class="i">CommandUtils</span> <span class="o">=</span> 
<span class="l">2: </span>  <span id="fst1" onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1, document.getElementById('fst1'))" class="omitted">(Implementation omitted)</span></pre>
<h3>LiterateUtils module</h3>

<p>Utilities for processing Markdown documents - extract links for references,
add links to references, extract code blocks for colorization and replace them
with formatted HTML (after running F# code formatter)</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">module</span> <span class="k">internal</span> <span class="i">LiterateUtils</span> <span class="o">=</span> 
<span class="l">2: </span>  <span id="fst2" onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2, document.getElementById('fst2'))" class="omitted">(Implementation omitted)</span></pre>
<h3>CodeBlockUtils module</h3>

<p>Parsing of F# Script files with Markdown commands. Given a parsed script file, we 
split it into a sequence of comments, snippets and commands (comment starts with 
<code>(**</code> and ending with <code>*)</code> are translated to Markdown, snippet is all other F# code 
and command looks like <code>(*** key1:value, key2:value ***)</code> (and should be single line).</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">module</span> <span class="k">internal</span> <span class="i">CodeBlockUtils</span> <span class="o">=</span>
<span class="l">2: </span>  <span id="fst3" onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3, document.getElementById('fst3'))" class="omitted">(Implementation omitted)</span></pre>
<h3>SourceProcessors module</h3>

<p>Functions that process <code>*.fsx</code> and <code>*.md</code> files. The function <code>processScriptFile</code>
assumes that the file is an F# script file (with text hidden in comments) while 
<code>processMarkdown</code> assumes that all F# code is included as code snippets.</p>
<pre class="fssnip">
<span class="l"> 1: </span><span class="k">module</span> <span class="k">internal</span> <span class="i">SourceProcessors</span> <span class="o">=</span> 
<span class="l"> 2: </span>
<span class="l"> 3: </span>  <span class="c">/// Specifies a context that is passed to the </span>
<span class="l"> 4: </span>  <span class="c">/// code/document processing functions</span>
<span class="l"> 5: </span>  <span class="k">type</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="i">ProcessingContext</span> <span class="o">=</span> 
<span class="l"> 6: </span>    { <span class="c">// An instance of the F# code formatting agent</span>
<span class="l"> 7: </span>      <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="i">FormatAgent</span> <span class="o">:</span> <span class="i">CodeFormatAgent</span> 
<span class="l"> 8: </span>      <span class="c">// Source code of a HTML template file</span>
<span class="l"> 9: </span>      <span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="i">Template</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="i">string</span>
<span class="l">10: </span>      <span class="c">// Short prefix code added to all HTML &#39;id&#39; elements</span>
<span class="l">11: </span>      <span onmouseout="hideTip(event, 'fs8', 8)" onmouseover="showTip(event, 'fs8', 8)" class="i">Prefix</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs7', 9)" onmouseover="showTip(event, 'fs7', 9)" class="i">string</span> 
<span class="l">12: </span>      <span class="c">// Should the processing add &#39;References&#39; section?</span>
<span class="l">13: </span>      <span onmouseout="hideTip(event, 'fs9', 10)" onmouseover="showTip(event, 'fs9', 10)" class="i">GenerateReferences</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs10', 11)" onmouseover="showTip(event, 'fs10', 11)" class="i">bool</span>
<span class="l">14: </span>      <span class="c">// Additional replacements to be made in the template file</span>
<span class="l">15: </span>      <span onmouseout="hideTip(event, 'fs11', 12)" onmouseover="showTip(event, 'fs11', 12)" class="i">Replacements</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs12', 13)" onmouseover="showTip(event, 'fs12', 13)" class="i">list</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs7', 14)" onmouseover="showTip(event, 'fs7', 14)" class="i">string</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs7', 15)" onmouseover="showTip(event, 'fs7', 15)" class="i">string</span><span class="o">&gt;</span> 
<span class="l">16: </span>      <span class="c">// Generate line numbers for F# snippets?</span>
<span class="l">17: </span>      <span onmouseout="hideTip(event, 'fs13', 16)" onmouseover="showTip(event, 'fs13', 16)" class="i">GenerateLineNumbers</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs10', 17)" onmouseover="showTip(event, 'fs10', 17)" class="i">bool</span> 
<span class="l">18: </span>      <span class="c">// Include the source file in the generated output as &#39;{source}&#39;</span>
<span class="l">19: </span>      <span onmouseout="hideTip(event, 'fs14', 18)" onmouseover="showTip(event, 'fs14', 18)" class="i">IncludeSource</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs10', 19)" onmouseover="showTip(event, 'fs10', 19)" class="i">bool</span>
<span class="l">20: </span>      <span class="c">// Command line options for the F# compiler</span>
<span class="l">21: </span>      <span onmouseout="hideTip(event, 'fs15', 20)" onmouseover="showTip(event, 'fs15', 20)" class="i">Options</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs7', 21)" onmouseover="showTip(event, 'fs7', 21)" class="i">string</span> 
<span class="l">22: </span>      <span class="c">// Custom function for reporting errors </span>
<span class="l">23: </span>      <span onmouseout="hideTip(event, 'fs16', 22)" onmouseover="showTip(event, 'fs16', 22)" class="i">ErrorHandler</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs17', 23)" onmouseover="showTip(event, 'fs17', 23)" class="i">option</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs7', 24)" onmouseover="showTip(event, 'fs7', 24)" class="i">string</span> <span class="o">*</span> <span class="i">SourceError</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 25)" onmouseover="showTip(event, 'fs18', 25)" class="i">unit</span><span class="o">&gt;</span> }
<span class="l">24: </span>
<span class="l">25: </span>  <span id="fst19" onmouseout="hideTip(event, 'fs19', 26)" onmouseover="showTip(event, 'fs19', 26, document.getElementById('fst19'))" class="omitted">(Implementation omitted)</span></pre>
<h2>Public API</h2>

<p>The following type provides three simple methods for calling the literate programming tool.
The <code>ProcessMarkdown</code> and <code>ProcessScriptFile</code> methods process a single Markdown document
and F# script, respectively. The <code>ProcessDirectory</code> method handles an entire directory tree
(looking for <code>*.fsx</code> and <code>*.md</code> files).</p>
<pre class="fssnip">
<span class="l"> 1: </span><span class="k">open</span> <span onmouseout="hideTip(event, 'fs20', 27)" onmouseover="showTip(event, 'fs20', 27)" class="i">SourceProcessors</span>
<span class="l"> 2: </span> 
<span class="l"> 3: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fs21', 28)" onmouseover="showTip(event, 'fs21', 28)" class="i">Literate</span> <span class="o">=</span> 
<span class="l"> 4: </span>  <span id="fst22" onmouseout="hideTip(event, 'fs22', 29)" onmouseover="showTip(event, 'fs22', 29, document.getElementById('fst22'))" class="omitted">(Helper methdods omitted)</span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>  <span class="c">/// Process Markdown document</span>
<span class="l"> 7: </span>  <span class="k">static</span> <span class="k">member</span> <span onmouseout="hideTip(event, 'fs23', 30)" onmouseover="showTip(event, 'fs23', 30)" class="i">ProcessMarkdown</span>
<span class="l"> 8: </span>    ( <span onmouseout="hideTip(event, 'fs24', 31)" onmouseover="showTip(event, 'fs24', 31)" class="i">input</span>, <span onmouseout="hideTip(event, 'fs25', 32)" onmouseover="showTip(event, 'fs25', 32)" class="i">templateFile</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs26', 33)" onmouseover="showTip(event, 'fs26', 33)" class="i">output</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs27', 34)" onmouseover="showTip(event, 'fs27', 34)" class="i">fsharpCompiler</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs28', 35)" onmouseover="showTip(event, 'fs28', 35)" class="i">prefix</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs29', 36)" onmouseover="showTip(event, 'fs29', 36)" class="i">compilerOptions</span>, 
<span class="l"> 9: </span>      <span class="o">?</span><span onmouseout="hideTip(event, 'fs30', 37)" onmouseover="showTip(event, 'fs30', 37)" class="i">lineNumbers</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs31', 38)" onmouseover="showTip(event, 'fs31', 38)" class="i">references</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs32', 39)" onmouseover="showTip(event, 'fs32', 39)" class="i">replacements</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs33', 40)" onmouseover="showTip(event, 'fs33', 40)" class="i">includeSource</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs34', 41)" onmouseover="showTip(event, 'fs34', 41)" class="i">errorHandler</span> ) <span class="o">=</span> <span id="fst35" onmouseout="hideTip(event, 'fs35', 42)" onmouseover="showTip(event, 'fs35', 42, document.getElementById('fst35'))" class="omitted">(...)</span>
<span class="l">10: </span>
<span class="l">11: </span>  <span class="c">/// Process F# Script file</span>
<span class="l">12: </span>  <span class="k">static</span> <span class="k">member</span> <span onmouseout="hideTip(event, 'fs36', 43)" onmouseover="showTip(event, 'fs36', 43)" class="i">ProcessScriptFile</span>
<span class="l">13: </span>    ( <span onmouseout="hideTip(event, 'fs24', 44)" onmouseover="showTip(event, 'fs24', 44)" class="i">input</span>, <span onmouseout="hideTip(event, 'fs25', 45)" onmouseover="showTip(event, 'fs25', 45)" class="i">templateFile</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs26', 46)" onmouseover="showTip(event, 'fs26', 46)" class="i">output</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs27', 47)" onmouseover="showTip(event, 'fs27', 47)" class="i">fsharpCompiler</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs28', 48)" onmouseover="showTip(event, 'fs28', 48)" class="i">prefix</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs29', 49)" onmouseover="showTip(event, 'fs29', 49)" class="i">compilerOptions</span>, 
<span class="l">14: </span>      <span class="o">?</span><span onmouseout="hideTip(event, 'fs30', 50)" onmouseover="showTip(event, 'fs30', 50)" class="i">lineNumbers</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs31', 51)" onmouseover="showTip(event, 'fs31', 51)" class="i">references</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs32', 52)" onmouseover="showTip(event, 'fs32', 52)" class="i">replacements</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs33', 53)" onmouseover="showTip(event, 'fs33', 53)" class="i">includeSource</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs34', 54)" onmouseover="showTip(event, 'fs34', 54)" class="i">errorHandler</span> ) <span class="o">=</span> <span id="fst37" onmouseout="hideTip(event, 'fs37', 55)" onmouseover="showTip(event, 'fs37', 55, document.getElementById('fst37'))" class="omitted">(...)</span>
<span class="l">15: </span>
<span class="l">16: </span>  <span class="c">/// Process directory containing a mix of Markdown documents and F# Script files</span>
<span class="l">17: </span>  <span class="k">static</span> <span class="k">member</span> <span onmouseout="hideTip(event, 'fs38', 56)" onmouseover="showTip(event, 'fs38', 56)" class="i">ProcessDirectory</span>
<span class="l">18: </span>    ( <span onmouseout="hideTip(event, 'fs39', 57)" onmouseover="showTip(event, 'fs39', 57)" class="i">inputDirectory</span>, <span onmouseout="hideTip(event, 'fs25', 58)" onmouseover="showTip(event, 'fs25', 58)" class="i">templateFile</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs40', 59)" onmouseover="showTip(event, 'fs40', 59)" class="i">outputDirectory</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs27', 60)" onmouseover="showTip(event, 'fs27', 60)" class="i">fsharpCompiler</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs28', 61)" onmouseover="showTip(event, 'fs28', 61)" class="i">prefix</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs29', 62)" onmouseover="showTip(event, 'fs29', 62)" class="i">compilerOptions</span>, 
<span class="l">19: </span>      <span class="o">?</span><span onmouseout="hideTip(event, 'fs30', 63)" onmouseover="showTip(event, 'fs30', 63)" class="i">lineNumbers</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs31', 64)" onmouseover="showTip(event, 'fs31', 64)" class="i">references</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs32', 65)" onmouseover="showTip(event, 'fs32', 65)" class="i">replacements</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs33', 66)" onmouseover="showTip(event, 'fs33', 66)" class="i">includeSource</span>, <span class="o">?</span><span onmouseout="hideTip(event, 'fs34', 67)" onmouseover="showTip(event, 'fs34', 67)" class="i">errorHandler</span> ) <span class="o">=</span> <span id="fst41" onmouseout="hideTip(event, 'fs41', 68)" onmouseover="showTip(event, 'fs41', 68, document.getElementById('fst41'))" class="omitted">(...)</span></pre>

          <div class="tip" id="fs1">let (|ParseCommands|_|) (str:string) = <br />&#160;&#160;&#160;&#160;let kvs = <br />&#160;&#160;&#160;&#160;&#160;&#160;[ for cmd in str.Split(&#39;,&#39;) do<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let kv = cmd.Split([| &#39;=&#39;; &#39;:&#39; |])<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if kv.Length = 2 then yield kv.[0].Trim(), kv.[1].Trim()<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif kv.Length = 1 then yield kv.[0].Trim(), &quot;&quot; ] <br />&#160;&#160;&#160;&#160;if kvs &lt;&gt; [] then Some(dict kvs) else None<br />&#160;&#160;<br />&#160;&#160;let (|Command|_|) k (d:IDictionary&lt;_, _&gt;) =<br />&#160;&#160;&#160;&#160;match d.TryGetValue(k) with<br />&#160;&#160;&#160;&#160;| true, v -&gt; Some v<br />&#160;&#160;&#160;&#160;| _ -&gt; None</div>
<div class="tip" id="fs2">open CommandUtils<br /><br />&#160;&#160;/// Given Markdown document, get the keys of all IndirectLinks <br />&#160;&#160;/// (to be used when generating paragraph with all references)<br />&#160;&#160;let rec collectReferences = <br /><br />&#160;&#160;&#160;&#160;// Collect IndirectLinks in a span<br />&#160;&#160;&#160;&#160;let rec collectSpanReferences span = seq { <br />&#160;&#160;&#160;&#160;&#160;&#160;match span with<br />&#160;&#160;&#160;&#160;&#160;&#160;| IndirectLink(_, _, key) -&gt; yield key<br />&#160;&#160;&#160;&#160;&#160;&#160;| Matching.SpanLeaf _ -&gt; ()<br />&#160;&#160;&#160;&#160;&#160;&#160;| Matching.SpanNode(_, spans) -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for s in spans do yield! collectSpanReferences s }<br /><br />&#160;&#160;&#160;&#160;// Collect IndirectLinks in a paragraph<br />&#160;&#160;&#160;&#160;let rec loop par = seq {<br />&#160;&#160;&#160;&#160;&#160;&#160;match par with<br />&#160;&#160;&#160;&#160;&#160;&#160;| Matching.ParagraphLeaf _ -&gt; ()<br />&#160;&#160;&#160;&#160;&#160;&#160;| Matching.ParagraphNested(_, pars) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ps in pars do <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for p in ps do yield! loop p <br />&#160;&#160;&#160;&#160;&#160;&#160;| Matching.ParagraphSpans(_, spans) -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for s in spans do yield! collectSpanReferences s }<br />&#160;&#160;&#160;&#160;loop <br /><br />&#160;&#160;/// Given Markdown document, add a number using the given index to all indirect <br />&#160;&#160;/// references. For example, [article][ref] becomes [article][ref] [1](#rfxyz)<br />&#160;&#160;let replaceReferences (refIndex:IDictionary&lt;string, int&gt;) =<br /><br />&#160;&#160;&#160;&#160;// Replace IndirectLinks with a nice link given a single span element<br />&#160;&#160;&#160;&#160;let rec replaceSpans = function<br />&#160;&#160;&#160;&#160;&#160;&#160;| IndirectLink(body, original, key) -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[ yield IndirectLink(body, original, key)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match refIndex.TryGetValue(key) with<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| true, i -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield Literal &quot;&amp;#160;[&quot;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield DirectLink([Literal (string i)], (&quot;#rf&quot; + DateTime.Now.ToString(&quot;yyMMddhh&quot;), None))<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield Literal &quot;]&quot;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| _ -&gt; () ]<br />&#160;&#160;&#160;&#160;&#160;&#160;| Matching.SpanLeaf(sl) -&gt; [Matching.SpanLeaf(sl)]<br />&#160;&#160;&#160;&#160;&#160;&#160;| Matching.SpanNode(nd, spans) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[ Matching.SpanNode(nd, List.collect replaceSpans spans) ]<br /><br />&#160;&#160;&#160;&#160;// Given a paragraph, process it recursively and transform all spans<br />&#160;&#160;&#160;&#160;let rec loop = function<br />&#160;&#160;&#160;&#160;&#160;&#160;| Matching.ParagraphNested(pn, nested) -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Matching.ParagraphNested(pn, List.map (List.choose loop) nested) |&gt; Some<br />&#160;&#160;&#160;&#160;&#160;&#160;| Matching.ParagraphSpans(ps, spans) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Matching.ParagraphSpans(ps, List.collect replaceSpans spans) |&gt; Some<br />&#160;&#160;&#160;&#160;&#160;&#160;| Matching.ParagraphLeaf(pl) -&gt; Matching.ParagraphLeaf(pl) |&gt; Some   <br />&#160;&#160;&#160;&#160;loop<br /><br />&#160;&#160;/// Iterate over Markdown document and extract all F# code snippets that we want<br />&#160;&#160;/// to colorize. We skip snippets that specify non-fsharp langauge e.g. [lang=csharp].<br />&#160;&#160;let rec collectCodeSnippets par = seq {<br />&#160;&#160;&#160;&#160;match par with<br />&#160;&#160;&#160;&#160;| CodeBlock(String.StartsWithWrapped (&quot;[&quot;, &quot;]&quot;) (ParseCommands cmds, String.TrimStart code)) <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;when cmds.ContainsKey(&quot;lang&quot;) &amp;&amp; cmds.[&quot;lang&quot;] &lt;&gt; &quot;fsharp&quot; -&gt; ()<br />&#160;&#160;&#160;&#160;| CodeBlock(String.StartsWithWrapped (&quot;[&quot;, &quot;]&quot;) (ParseCommands cmds, String.TrimStart code)) <br />&#160;&#160;&#160;&#160;| CodeBlock(Let (dict []) (cmds, code)) -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let modul = <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match cmds.TryGetValue(&quot;module&quot;) with<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| true, v -&gt; Some v | _ -&gt; None<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield modul, code<br />&#160;&#160;&#160;&#160;| Matching.ParagraphLeaf _ -&gt; ()<br />&#160;&#160;&#160;&#160;| Matching.ParagraphNested(_, pars) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ps in pars do <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for p in ps do yield! collectCodeSnippets p <br />&#160;&#160;&#160;&#160;| Matching.ParagraphSpans(_, spans) -&gt; () }<br /><br />&#160;&#160;/// Replace CodeBlock elements with formatted HTML that was processed by the F# snippets tool<br />&#160;&#160;/// (The dictionary argument is a map from original code snippets to formatted HTML snippets.)<br />&#160;&#160;let rec replaceCodeSnippets (codeLookup:IDictionary&lt;_, _&gt;) = function<br />&#160;&#160;&#160;&#160;| CodeBlock(String.StartsWithWrapped (&quot;[&quot;, &quot;]&quot;) (ParseCommands cmds, String.TrimStart code)) <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;when cmds.ContainsKey(&quot;hide&quot;) -&gt; None<br />&#160;&#160;&#160;&#160;| CodeBlock(String.StartsWithWrapped (&quot;[&quot;, &quot;]&quot;) (ParseCommands cmds, String.TrimStart code)) <br />&#160;&#160;&#160;&#160;| CodeBlock(Let (dict []) (cmds, code)) -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (cmds.ContainsKey(&quot;lang&quot;)) &amp;&amp; cmds.[&quot;lang&quot;] &lt;&gt; &quot;fsharp&quot; then <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let html = &quot;&lt;pre lang=\&quot;&quot; + cmds.[&quot;lang&quot;] + &quot;\&quot;&gt;&quot; + HttpUtility.HtmlEncode(code) + &quot;&lt;/pre&gt;&quot;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;HtmlBlock(html) |&gt; Some<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let html : string = codeLookup.[code]<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;HtmlBlock(html) |&gt; Some<br /><br />&#160;&#160;&#160;&#160;// Recursively process nested paragraphs, other nodes return without change<br />&#160;&#160;&#160;&#160;| Matching.ParagraphNested(pn, nested) -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let pars = List.map (List.choose (replaceCodeSnippets codeLookup)) nested<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Matching.ParagraphNested(pn, pars) |&gt; Some<br />&#160;&#160;&#160;&#160;| other -&gt; Some other<br /><br />&#160;&#160;/// Try find first-level heading in the paragraph collection<br />&#160;&#160;let findHeadings paragraphs =              <br />&#160;&#160;&#160;&#160;paragraphs |&gt; Seq.tryPick (function <br />&#160;&#160;&#160;&#160;&#160;&#160;| (Heading(1, text)) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let doc = MarkdownDocument([Span(text)], dict [])<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(Markdown.WriteHtml(doc))<br />&#160;&#160;&#160;&#160;&#160;&#160;| _ -&gt; None)</div>
<div class="tip" id="fs3">open CommandUtils<br /><br />&#160;&#160;type Block = <br />&#160;&#160;&#160;&#160;| BlockComment of string<br />&#160;&#160;&#160;&#160;| BlockSnippet of Line list <br />&#160;&#160;&#160;&#160;| BlockCommand of IDictionary&lt;string, string&gt;<br /><br />&#160;&#160;/// Trim blank lines from both ends of a lines list &amp; reverse it (we accumulate <br />&#160;&#160;/// lines &amp; we want to remove all blanks before returning BlockSnippet)<br />&#160;&#160;let private trimBlanksAndReverse lines = <br />&#160;&#160;&#160;&#160;lines <br />&#160;&#160;&#160;&#160;|&gt; Seq.skipWhile (function Line[] -&gt; true | _ -&gt; false)<br />&#160;&#160;&#160;&#160;|&gt; List.ofSeq |&gt; List.rev<br />&#160;&#160;&#160;&#160;|&gt; Seq.skipWhile (function Line[] -&gt; true | _ -&gt; false)<br />&#160;&#160;&#160;&#160;|&gt; List.ofSeq<br /><br />&#160;&#160;/// Succeeds when a line (list of tokens) contains only Comment <br />&#160;&#160;/// tokens and returns the text from the comment as a string<br />&#160;&#160;let private (|ConcatenatedComments|_|) (Line tokens) =<br />&#160;&#160;&#160;&#160;let comments =<br />&#160;&#160;&#160;&#160;&#160;&#160;tokens |&gt; List.choose (function<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| Token(TokenKind.Comment, text, _) -&gt; Some text<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| _ -&gt; None)<br />&#160;&#160;&#160;&#160;if comments.Length &lt;&gt; tokens.Length then None<br />&#160;&#160;&#160;&#160;else Some (String.concat &quot;&quot; comments)<br /><br />&#160;&#160;// Process lines of an F# script file. Simple state machine with two states<br />&#160;&#160;//  * collectComment - we&#39;re parsing a comment and waiting for the end<br />&#160;&#160;//  * collectSnippet - we&#39;re in a normal F# code and we&#39;re waiting for a comment<br />&#160;&#160;//    (in both states, we also need to recognize (*** commands ***)<br /><br />&#160;&#160;/// Waiting for the end of a comment      <br />&#160;&#160;let rec private collectComment (comment:string) lines = seq {<br />&#160;&#160;&#160;&#160;match lines with<br />&#160;&#160;&#160;&#160;| (ConcatenatedComments(String.StartsAndEndsWith (&quot;(***&quot;, &quot;***)&quot;) (ParseCommands cmds)))::lines -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Ended with a command, yield comment, command &amp; parse the next as a snippet<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let cend = comment.LastIndexOf(&quot;*)&quot;)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield BlockComment (comment.Substring(0, cend))<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield BlockCommand cmds<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield! collectSnippet [] lines<br />&#160;&#160;&#160;&#160;| (ConcatenatedComments text)::_ when <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;comment.LastIndexOf(&quot;*)&quot;) &lt;&gt; -1 &amp;&amp; text.Trim().StartsWith(&quot;//&quot;) -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Comment ended, but we found a code snippet starting with // comment<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let cend = comment.LastIndexOf(&quot;*)&quot;)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield BlockComment (comment.Substring(0, cend))<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield! collectSnippet [] lines<br />&#160;&#160;&#160;&#160;| (ConcatenatedComments text)::lines  -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Continue parsing comment<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield! collectComment (comment + &quot;\n&quot; + text) lines<br />&#160;&#160;&#160;&#160;| lines -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Ended - yield comment &amp; continue parsing snippet<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let cend = comment.LastIndexOf(&quot;*)&quot;)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield BlockComment (comment.Substring(0, cend))<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if lines &lt;&gt; [] then yield! collectSnippet [] lines }<br /><br />&#160;&#160;/// Collecting a block of F# snippet<br />&#160;&#160;and private collectSnippet acc lines = seq {<br />&#160;&#160;&#160;&#160;match lines with <br />&#160;&#160;&#160;&#160;| (ConcatenatedComments(String.StartsAndEndsWith (&quot;(***&quot;, &quot;***)&quot;) (ParseCommands cmds)))::lines -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Found a special command, yield snippet, command and parse another snippet<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if acc &lt;&gt; [] then yield BlockSnippet (trimBlanksAndReverse acc)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield BlockCommand cmds<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield! collectSnippet [] lines<br /><br />&#160;&#160;&#160;&#160;| (Line[Token(TokenKind.Comment, String.StartsWith &quot;(**&quot; text, _)])::lines -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Found a comment - yield snippet &amp; switch to parsing comment state<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if acc &lt;&gt; [] then yield BlockSnippet (trimBlanksAndReverse acc)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield! collectComment text lines<br /><br />&#160;&#160;&#160;&#160;| x::xs -&gt;  yield! collectSnippet (x::acc) xs<br />&#160;&#160;&#160;&#160;| [] -&gt; yield BlockSnippet (trimBlanksAndReverse acc) }<br /><br />&#160;&#160;/// Parse F# script file into a sequence of snippets, comments and commands<br />&#160;&#160;let parseScriptFile = collectSnippet []<br /><br />&#160;&#160;/// Given a parsed script file, extract &quot;definitions&quot;. A definition is a part of <br />&#160;&#160;/// the file that we want to include elsewhere (and hide in the original location):<br />&#160;&#160;///<br />&#160;&#160;///     (*** define:key ***)<br />&#160;&#160;///     let foo = 1 + 2<br />&#160;&#160;///<br />&#160;&#160;/// This function returns &#39;string * Block&#39; list containing all definitions <br />&#160;&#160;/// together with all a list of all remaining blocks that were not extracted.<br />&#160;&#160;let extractDefinitions defns =<br />&#160;&#160;&#160;&#160;let rec loop defns normal = function<br />&#160;&#160;&#160;&#160;&#160;&#160;| [] -&gt; defns, normal |&gt; List.rev<br />&#160;&#160;&#160;&#160;&#160;&#160;| BlockCommand(Command &quot;hide&quot; _)::(BlockSnippet _)::rest -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loop defns normal rest<br />&#160;&#160;&#160;&#160;&#160;&#160;| BlockCommand(Command &quot;define&quot; key)::(BlockSnippet lines)::rest -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// If we have command with &#39;define&#39; in it, then pick the following <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// snippet (it should be a snippet) and return it as a definition<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loop ((key, lines)::defns) normal rest<br />&#160;&#160;&#160;&#160;&#160;&#160;| current::rest -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loop defns (current::normal) rest<br />&#160;&#160;&#160;&#160;defns |&gt; List.ofSeq |&gt; loop [] []</div>
<div class="tip" id="fs4">type internal ProcessingContext =<br />&#160;&#160;{FormatAgent: obj;<br />&#160;&#160;&#160;Template: string;<br />&#160;&#160;&#160;Prefix: string;<br />&#160;&#160;&#160;GenerateReferences: bool;<br />&#160;&#160;&#160;Replacements: (string * string) list;<br />&#160;&#160;&#160;GenerateLineNumbers: bool;<br />&#160;&#160;&#160;IncludeSource: bool;<br />&#160;&#160;&#160;Options: string;<br />&#160;&#160;&#160;ErrorHandler: (string * obj -&gt; unit) option;}<br /><br />完全名: FSharp.Literate.SourceProcessors.ProcessingContext<br /><em><br /><br />&#160;Specifies a context that is passed to the <br />&#160;code/document processing functions</em></div>
<div class="tip" id="fs5">ProcessingContext.FormatAgent: obj</div>
<div class="tip" id="fs6">ProcessingContext.Template: string</div>
<div class="tip" id="fs7">Multiple items<br />val string : value:&#39;T -&gt; string<br /><br />完全名: Microsoft.FSharp.Core.Operators.string<br /><br />--------------------<br />type string = String<br /><br />完全名: Microsoft.FSharp.Core.string</div>
<div class="tip" id="fs8">ProcessingContext.Prefix: string</div>
<div class="tip" id="fs9">ProcessingContext.GenerateReferences: bool</div>
<div class="tip" id="fs10">type bool = Boolean<br /><br />完全名: Microsoft.FSharp.Core.bool</div>
<div class="tip" id="fs11">ProcessingContext.Replacements: (string * string) list</div>
<div class="tip" id="fs12">type &#39;T list = List&lt;&#39;T&gt;<br /><br />完全名: Microsoft.FSharp.Collections.list&lt;_&gt;</div>
<div class="tip" id="fs13">ProcessingContext.GenerateLineNumbers: bool</div>
<div class="tip" id="fs14">ProcessingContext.IncludeSource: bool</div>
<div class="tip" id="fs15">ProcessingContext.Options: string</div>
<div class="tip" id="fs16">ProcessingContext.ErrorHandler: (string * obj -&gt; unit) option</div>
<div class="tip" id="fs17">type &#39;T option = Option&lt;&#39;T&gt;<br /><br />完全名: Microsoft.FSharp.Core.option&lt;_&gt;</div>
<div class="tip" id="fs18">type unit = Unit<br /><br />完全名: Microsoft.FSharp.Core.unit</div>
<div class="tip" id="fs19">open CommandUtils<br />&#160;&#160;open CodeBlockUtils<br />&#160;&#160;open LiterateUtils<br />&#160;&#160;<br />&#160;&#160;/// Print information about all errors during the processing<br />&#160;&#160;let private reportErrors ctx file (errors:seq&lt;SourceError&gt;) = <br />&#160;&#160;&#160;&#160;match ctx.ErrorHandler with<br />&#160;&#160;&#160;&#160;| Some eh -&gt; for e in errors do eh(file, e)<br />&#160;&#160;&#160;&#160;| _ -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (SourceError((sl, sc), (el, ec), kind, msg)) in errors do<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printfn &quot;   * (%d:%d)-(%d:%d) (%A): %s&quot; sl sc el ec kind msg<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if Seq.length errors &gt; 0 then printfn &quot;&quot;<br /><br />&#160;&#160;/// Given all links defined in the Markdown document and a list of all links<br />&#160;&#160;/// that are accessed somewhere from the document, generate References paragraph<br />&#160;&#160;let generateReferences (definedLinks:IDictionary&lt;_, string * string option&gt;) refs = <br />&#160;&#160;&#160;&#160;<br />&#160;&#160;&#160;&#160;// For all unique references in the document, <br />&#160;&#160;&#160;&#160;// get the link &amp; title from definitions<br />&#160;&#160;&#160;&#160;let refs = <br />&#160;&#160;&#160;&#160;&#160;&#160;refs |&gt; set |&gt; Seq.choose (fun ref -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match definedLinks.TryGetValue(ref) with<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| true, (link, Some title) -&gt; Some (ref, link, title)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| _ -&gt; None)<br />&#160;&#160;&#160;&#160;&#160;&#160;|&gt; Seq.sort |&gt; Seq.mapi (fun i v -&gt; i+1, v)<br />&#160;&#160;&#160;&#160;// Generate dictionary with a number for all references<br />&#160;&#160;&#160;&#160;let refLookup = dict [ for (i, (r, _, _)) in refs -&gt; r, i ]<br /><br />&#160;&#160;&#160;&#160;// Generate Markdown blocks paragraphs representing Reference &lt;li&gt; items<br />&#160;&#160;&#160;&#160;let refList = <br />&#160;&#160;&#160;&#160;&#160;&#160;[ for i, (ref, link, title) in refs do <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let colon = title.IndexOf(&quot;:&quot;)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if colon &gt; 0 then<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let auth = title.Substring(0, colon)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let name = title.Substring(colon + 1, title.Length - 1 - colon)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield [Span [ Literal (sprintf &quot;[%d] &quot; i)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DirectLink([Literal name], (link, Some title))<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Literal (&quot; - &quot; + auth)] ] <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;yield [Span [ Literal (sprintf &quot;[%d] &quot; i)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DirectLink([Literal title], (link, Some title))]]  ]<br /><br />&#160;&#160;&#160;&#160;// Return the document together with dictionary for looking up indices<br />&#160;&#160;&#160;&#160;let id = DateTime.Now.ToString(&quot;yyMMddhh&quot;)<br />&#160;&#160;&#160;&#160;[ Heading(3, [Literal (&quot;&lt;a name=\&quot;rf&quot; + id + &quot;\&quot;&gt;&amp;#160;&lt;/a&gt;References&quot;) ])<br />&#160;&#160;&#160;&#160;&#160;&#160;ListBlock(MarkdownListKind.Unordered, refList) ], refLookup<br /><br />&#160;&#160;/// Replace {parameter} in the input string with <br />&#160;&#160;/// values defined in the specified list<br />&#160;&#160;let replaceParameters parameters input = <br />&#160;&#160;&#160;&#160;// First replace keys with some uglier keys and then replace them with values<br />&#160;&#160;&#160;&#160;// (in case one of the keys appears in some other value)<br />&#160;&#160;&#160;&#160;let id = System.Guid.NewGuid().ToString(&quot;d&quot;)<br />&#160;&#160;&#160;&#160;let input = parameters |&gt; Seq.fold (fun (html:string) (key, value) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;html.Replace(&quot;{&quot; + key + &quot;}&quot;, &quot;{&quot; + key + id + &quot;}&quot;)) input<br />&#160;&#160;&#160;&#160;let result = parameters |&gt; Seq.fold (fun (html:string) (key, value) -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;html.Replace(&quot;{&quot; + key + id + &quot;}&quot;, value)) input<br />&#160;&#160;&#160;&#160;result <br /><br />&#160;&#160;/// Write formatted blocks to a specified string builder <br />&#160;&#160;/// and return first-level heading if there is some<br />&#160;&#160;let outputBlocks (sb:Text.StringBuilder) <br />&#160;&#160;&#160;&#160;&#160;&#160;// Original blocks of the input document<br />&#160;&#160;&#160;&#160;&#160;&#160;blocks<br />&#160;&#160;&#160;&#160;&#160;&#160;// Sequence with just formatted BlockSnippet elements<br />&#160;&#160;&#160;&#160;&#160;&#160;(snippets:seq&lt;FormattedSnippet&gt;)<br />&#160;&#160;&#160;&#160;&#160;&#160;// Sequence with just formatted BlockComment elements<br />&#160;&#160;&#160;&#160;&#160;&#160;(comments:seq&lt;MarkdownDocument&gt;)<br />&#160;&#160;&#160;&#160;&#160;&#160;(definitions:IDictionary&lt;_, string&gt;) refLookup =<br />&#160;&#160;&#160;&#160;<br />&#160;&#160;&#160;&#160;// We traverse sequences using enumerators as we need them<br />&#160;&#160;&#160;&#160;let heading = ref None<br />&#160;&#160;&#160;&#160;use snippetsEn = snippets.GetEnumerator()<br />&#160;&#160;&#160;&#160;use commentsEn = comments.GetEnumerator()<br />&#160;&#160;&#160;&#160;let nextSnippet () = snippetsEn.MoveNext() |&gt; ignore; snippetsEn.Current<br />&#160;&#160;&#160;&#160;let nextComment () = commentsEn.MoveNext() |&gt; ignore; commentsEn.Current<br /><br />&#160;&#160;&#160;&#160;for block in blocks do<br />&#160;&#160;&#160;&#160;&#160;&#160;match block with<br />&#160;&#160;&#160;&#160;&#160;&#160;// Skip known commands and comments (&#39;hide&#39; is removed in earlier step)<br />&#160;&#160;&#160;&#160;&#160;&#160;| BlockCommand (Command &quot;include&quot; key) -&gt; sb.Append(definitions.[key]) |&gt; ignore<br />&#160;&#160;&#160;&#160;&#160;&#160;| BlockCommand (Command &quot;define&quot; _) -&gt; ()<br />&#160;&#160;&#160;&#160;&#160;&#160;| BlockCommand cmds when cmds.Count = 1 &amp;&amp; cmds.Keys |&gt; Seq.head |&gt; Seq.forall ((=) &#39;*&#39;) -&gt; ()<br />&#160;&#160;&#160;&#160;&#160;&#160;| BlockCommand cmds -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;failwithf &quot;Unsupported command: %s&quot; (String.concat &quot;, &quot; [ for (KeyValue(k,v)) in cmds -&gt; k + &quot;:&quot; + v ])<br /><br />&#160;&#160;&#160;&#160;&#160;&#160;// Emit next comment, but search for headings<br />&#160;&#160;&#160;&#160;&#160;&#160;| BlockComment s -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let mdoc = nextComment()<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let paragraphs = mdoc.Paragraphs |&gt; List.choose (replaceReferences refLookup) <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;findHeadings paragraphs |&gt; Option.iter (fun v -&gt; heading := Some v)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sb.Append(Markdown.WriteHtml(MarkdownDocument(paragraphs, mdoc.DefinedLinks))) |&gt; ignore<br />&#160;&#160;&#160;&#160;&#160;&#160;<br />&#160;&#160;&#160;&#160;&#160;&#160;// Emit next snippet (if it is not just empty list)<br />&#160;&#160;&#160;&#160;&#160;&#160;| BlockSnippet lines -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let snip = nextSnippet()<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if lines &lt;&gt; [] then sb.Append(snip.Html) |&gt; ignore<br />&#160;&#160;&#160;&#160;!heading<br /><br />&#160;&#160;// ------------------------------------------------------------------------------------<br /><br />&#160;&#160;/// Process F# Script file<br />&#160;&#160;let processScriptFile ctx file output =<br />&#160;&#160;&#160;&#160;let name = Path.GetFileNameWithoutExtension(file)<br /><br />&#160;&#160;&#160;&#160;// Parse the entire file as an F# script file,<br />&#160;&#160;&#160;&#160;// get sequence of blocks &amp; extract definitions<br />&#160;&#160;&#160;&#160;let sourceSnippets, errors = ctx.FormatAgent.ParseSource(file, File.ReadAllText(file), ctx.Options)<br />&#160;&#160;&#160;&#160;reportErrors ctx file errors<br />&#160;&#160;&#160;&#160;let (Snippet(_, lines)) = match sourceSnippets with [| it |] -&gt; it | _ -&gt; failwith &quot;multiple snippets&quot;<br />&#160;&#160;&#160;&#160;let definitions, blocks = parseScriptFile lines |&gt; extractDefinitions<br /><br />&#160;&#160;&#160;&#160;// Process all definitions &amp; build a dictionary with HTML for each definition<br />&#160;&#160;&#160;&#160;let snippets = [| for name, lines in definitions -&gt; Snippet(name, lines) |] <br />&#160;&#160;&#160;&#160;let formattedDefns = CodeFormat.FormatHtml(snippets, ctx.Prefix + &quot;d&quot;, ctx.GenerateLineNumbers, false)<br />&#160;&#160;&#160;&#160;let definitions = dict [ for snip in formattedDefns.SnippetsHtml -&gt; snip.Title, snip.Html ]<br />&#160;&#160;&#160;&#160;<br />&#160;&#160;&#160;&#160;// Process all snippet blocks in the script file (using F# formatter)<br />&#160;&#160;&#160;&#160;let snippets = blocks |&gt; List.choose (function<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| BlockSnippet(lines) -&gt; Some(Snippet(&quot;Untitled&quot;, lines))<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| _ -&gt; None) |&gt; Array.ofList<br />&#160;&#160;&#160;&#160;let formatted = CodeFormat.FormatHtml(snippets, ctx.Prefix, ctx.GenerateLineNumbers, false)<br /><br />&#160;&#160;&#160;&#160;// Parse all comment blocks in the script file (as Markdown)<br />&#160;&#160;&#160;&#160;let parsedBlocks = blocks |&gt; Array.ofSeq |&gt; Seq.choose (function<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| BlockComment(text) -&gt; Some(Markdown.Parse(text))<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| _ -&gt; None) <br /><br />&#160;&#160;&#160;&#160;// Turn all indirect links into a references &amp; add paragraph to the document<br />&#160;&#160;&#160;&#160;let refParagraph, refLookup = <br />&#160;&#160;&#160;&#160;&#160;&#160;if ctx.GenerateReferences then <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Union link definitions &amp; collect all indirect links<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let definedLinks = parsedBlocks |&gt; Seq.collect (fun mdoc -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[ for (KeyValue(k, v)) in mdoc.DefinedLinks -&gt; k, v]) |&gt; dict<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let refs = parsedBlocks |&gt; Seq.collect (fun mdoc -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Seq.collect collectReferences mdoc.Paragraphs)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let pars, refLookup = generateReferences definedLinks refs<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some pars, refLookup<br />&#160;&#160;&#160;&#160;&#160;&#160;else None, dict []<br /><br />&#160;&#160;&#160;&#160;// Write all HTML content to a string builder &amp; add References    <br />&#160;&#160;&#160;&#160;let sb = Text.StringBuilder()<br />&#160;&#160;&#160;&#160;let heading = outputBlocks sb blocks formatted.SnippetsHtml parsedBlocks definitions refLookup<br />&#160;&#160;&#160;&#160;refParagraph |&gt; Option.iter (fun p -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;sb.Append(Markdown.WriteHtml(MarkdownDocument(p, dict []))) |&gt; ignore)    <br />&#160;&#160;&#160;&#160;<br />&#160;&#160;&#160;&#160;// If we want to include the source code of the script, then process<br />&#160;&#160;&#160;&#160;// the entire source and generate replacement {source} =&gt; ...some html...<br />&#160;&#160;&#160;&#160;let sourceRepalcement, sourceTips =<br />&#160;&#160;&#160;&#160;&#160;&#160;if ctx.IncludeSource then <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let formatted = CodeFormat.FormatHtml(sourceSnippets, ctx.Prefix + &quot;s&quot;)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let html =<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match formatted.SnippetsHtml with<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| [| snip |] -&gt; snip.Html<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| snips -&gt; [ for s in snips -&gt; sprintf &quot;&lt;h3&gt;%s&lt;/h3&gt;\n%s&quot; s.Title s.Html ] |&gt; String.concat &quot;&quot;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[ &quot;source&quot;, html ], formatted.ToolTipHtml<br />&#160;&#160;&#160;&#160;&#160;&#160;else [], &quot;&quot;<br /><br />&#160;&#160;&#160;&#160;// Repalce all parameters in the template &amp; write to output<br />&#160;&#160;&#160;&#160;let parameters = <br />&#160;&#160;&#160;&#160;&#160;&#160;ctx.Replacements @ sourceRepalcement @<br />&#160;&#160;&#160;&#160;&#160;&#160;[ &quot;page-title&quot;, defaultArg heading name<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;document&quot;, sb.ToString()<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;tooltips&quot;, formatted.ToolTipHtml + formattedDefns.ToolTipHtml + sourceTips ]<br />&#160;&#160;&#160;&#160;File.WriteAllText(output, replaceParameters parameters ctx.Template)<br /><br />&#160;&#160;// ------------------------------------------------------------------------------------<br /><br />&#160;&#160;/// Process Markdown document<br />&#160;&#160;let processMarkdown ctx file output =<br />&#160;&#160;&#160;&#160;// Read file &amp; parse Markdown document<br />&#160;&#160;&#160;&#160;let name = Path.GetFileNameWithoutExtension(file)<br />&#160;&#160;&#160;&#160;let originalSource = File.ReadAllText(file)<br />&#160;&#160;&#160;&#160;let doc = Markdown.Parse(originalSource)<br /><br />&#160;&#160;&#160;&#160;// Turn all indirect links into a references &amp; add paragraph to the document<br />&#160;&#160;&#160;&#160;let refParagraph, refLookup = <br />&#160;&#160;&#160;&#160;&#160;&#160;if ctx.GenerateReferences then <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Union link definitions &amp; collect all indirect links<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let refs = Seq.collect collectReferences doc.Paragraphs<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let pars, refLookup = generateReferences doc.DefinedLinks refs<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some pars, refLookup<br />&#160;&#160;&#160;&#160;&#160;&#160;else None, dict []<br />&#160;&#160;&#160;&#160;<br />&#160;&#160;&#160;&#160;// Extract all CodeBlocks and pass them to F# snippets<br />&#160;&#160;&#160;&#160;let codes = doc.Paragraphs |&gt; Seq.collect collectCodeSnippets |&gt; Array.ofSeq<br />&#160;&#160;&#160;&#160;let codeLookup, tipsHtml = <br />&#160;&#160;&#160;&#160;&#160;&#160;if codes.Length = 0 then dict [], &quot;&quot;<br />&#160;&#160;&#160;&#160;&#160;&#160;else<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// If there are some F# snippets, we build an F# source file<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let blocks = codes |&gt; Seq.mapi (fun index (modul, code) -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match modul with<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| Some modul -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// generate module &amp; add indentation<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;module &quot; + modul + &quot; =\n&quot; +<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;// [snippet:&quot; + (string index) + &quot;]\n&quot; +<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;    &quot; + code.Replace(&quot;\n&quot;, &quot;\n    &quot;) + &quot;\n&quot; +<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;// [/snippet]&quot;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| None -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;// [snippet:&quot; + (string index) + &quot;]\n&quot; +<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;code + &quot;\n&quot; +<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;// [/snippet]&quot; ) <br /><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Process F# script file, report errors &amp; build lookup table for replacement<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let modul = &quot;module &quot; + (new String(name |&gt; Seq.filter Char.IsLetter |&gt; Seq.toArray))<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let source = modul + &quot;\r\n&quot; + (String.concat &quot;\n\n&quot; blocks)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let snippets, errors = ctx.FormatAgent.ParseSource(output + &quot;.fs&quot;, source, ctx.Options)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reportErrors ctx file errors<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let formatted = CodeFormat.FormatHtml(snippets, ctx.Prefix, ctx.GenerateLineNumbers, false)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let snippetLookup = <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[ for (_, code), fs in Array.zip codes formatted.SnippetsHtml -&gt; code, fs.Html ]<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dict snippetLookup, formatted.ToolTipHtml<br /><br />&#160;&#160;&#160;&#160;// Process all paragraphs in two steps (replace F# snippets &amp; references)<br />&#160;&#160;&#160;&#160;let paragraphs = <br />&#160;&#160;&#160;&#160;&#160;&#160;doc.Paragraphs |&gt; List.choose (fun par -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;par |&gt; replaceCodeSnippets codeLookup<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&gt; Option.bind (replaceReferences refLookup)) <br /><br />&#160;&#160;&#160;&#160;// If we want to include the source code of the script, then process<br />&#160;&#160;&#160;&#160;// the entire source and generate replacement {source} =&gt; ...some html...<br />&#160;&#160;&#160;&#160;let sourceReplacements =<br />&#160;&#160;&#160;&#160;&#160;&#160;if ctx.IncludeSource then<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let html = Markdown.WriteHtml(MarkdownDocument([CodeBlock originalSource], dict []))<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[ &quot;source&quot;, html ]<br />&#160;&#160;&#160;&#160;&#160;&#160;else []<br /><br />&#160;&#160;&#160;&#160;// Construct new Markdown document and write it<br />&#160;&#160;&#160;&#160;let parameters = <br />&#160;&#160;&#160;&#160;&#160;&#160;ctx.Replacements @ sourceReplacements @<br />&#160;&#160;&#160;&#160;&#160;&#160;[ &quot;page-title&quot;, defaultArg (findHeadings paragraphs) name<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;document&quot;, Markdown.WriteHtml(MarkdownDocument(paragraphs, doc.DefinedLinks))<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;tooltips&quot;, tipsHtml ]<br />&#160;&#160;&#160;&#160;File.WriteAllText(output, replaceParameters parameters ctx.Template)</div>
<div class="tip" id="fs20">モジュール SourceProcessors<br /><br />FSharp.Literate から</div>
<div class="tip" id="fs21">type Literate =<br />&#160;&#160;static member private DefaultArguments : input:string * templateFile:string * output:string option * fsharpCompiler:Assembly option * prefix:string option * compilerOptions:string option * lineNumbers:bool option * references:bool option * replacements:(string * string) list option * includeSource:bool option * errorHandler:(string * obj -&gt; unit) option -&gt; string * ProcessingContext<br />&#160;&#160;static member ProcessDirectory : inputDirectory:string * templateFile:string * ?outputDirectory:string * ?fsharpCompiler:Assembly * ?prefix:string * ?compilerOptions:string * ?lineNumbers:bool * ?references:bool * ?replacements:(string * string) list * ?includeSource:bool * ?errorHandler:(string * obj -&gt; unit) -&gt; unit<br />&#160;&#160;static member ProcessMarkdown : input:string * templateFile:string * ?output:string * ?fsharpCompiler:Assembly * ?prefix:string * ?compilerOptions:string * ?lineNumbers:bool * ?references:bool * ?replacements:(string * string) list * ?includeSource:bool * ?errorHandler:(string * obj -&gt; unit) -&gt; unit<br />&#160;&#160;static member ProcessScriptFile : input:string * templateFile:string * ?output:string * ?fsharpCompiler:Assembly * ?prefix:string * ?compilerOptions:string * ?lineNumbers:bool * ?references:bool * ?replacements:(string * string) list * ?includeSource:bool * ?errorHandler:(string * obj -&gt; unit) -&gt; &#39;a<br /><br />完全名: FSharp.Literate.Literate</div>
<div class="tip" id="fs22">/// Provides default values for all optional parameters<br />&#160;&#160;static member private DefaultArguments<br />&#160;&#160;&#160;&#160;&#160;&#160;( input, templateFile, output, fsharpCompiler, prefix, compilerOptions, <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lineNumbers, references, replacements, includeSource, errorHandler) = <br />&#160;&#160;&#160;&#160;let defaultArg v f = match v with Some v -&gt; v | _ -&gt; f()<br />&#160;&#160;&#160;&#160;let output = defaultArg output (fun () -&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;let dir = Path.GetDirectoryName(input)<br />&#160;&#160;&#160;&#160;&#160;&#160;let file = Path.GetFileNameWithoutExtension(input)<br />&#160;&#160;&#160;&#160;&#160;&#160;Path.Combine(dir, file + &quot;.html&quot;))<br />&#160;&#160;&#160;&#160;let fsharpCompiler = defaultArg fsharpCompiler (fun () -&gt; <br />&#160;&#160;&#160;&#160;&#160;&#160;Assembly.Load(&quot;FSharp.Compiler&quot;))<br />&#160;&#160;&#160;&#160;<br />&#160;&#160;&#160;&#160;// Build &amp; return processing context<br />&#160;&#160;&#160;&#160;let ctx = <br />&#160;&#160;&#160;&#160;&#160;&#160;{ FormatAgent = CodeFormat.CreateAgent(fsharpCompiler) <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Template = File.ReadAllText(templateFile)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Prefix = defaultArg prefix (fun () -&gt; &quot;fs&quot;)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Options = defaultArg compilerOptions (fun () -&gt; &quot;&quot;)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;GenerateLineNumbers = defaultArg lineNumbers (fun () -&gt; true)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;GenerateReferences = defaultArg references (fun () -&gt; false)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Replacements = defaultArg replacements (fun () -&gt; []) <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;IncludeSource = defaultArg includeSource (fun () -&gt; false) <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ErrorHandler = errorHandler }<br />&#160;&#160;&#160;&#160;output, ctx</div>
<div class="tip" id="fs23">static member Literate.ProcessMarkdown : input:string * templateFile:string * ?output:string * ?fsharpCompiler:Assembly * ?prefix:string * ?compilerOptions:string * ?lineNumbers:bool * ?references:bool * ?replacements:(string * string) list * ?includeSource:bool * ?errorHandler:(string * obj -&gt; unit) -&gt; unit<br /><br />完全名: FSharp.Literate.Literate.ProcessMarkdown<br /><em><br /><br />&#160;Process Markdown document</em></div>
<div class="tip" id="fs24">val input : string</div>
<div class="tip" id="fs25">val templateFile : string</div>
<div class="tip" id="fs26">val output : string option</div>
<div class="tip" id="fs27">val fsharpCompiler : Assembly option</div>
<div class="tip" id="fs28">val prefix : string option</div>
<div class="tip" id="fs29">val compilerOptions : string option</div>
<div class="tip" id="fs30">val lineNumbers : bool option</div>
<div class="tip" id="fs31">val references : bool option</div>
<div class="tip" id="fs32">val replacements : (string * string) list option</div>
<div class="tip" id="fs33">val includeSource : bool option</div>
<div class="tip" id="fs34">val errorHandler : (string * obj -&gt; unit) option</div>
<div class="tip" id="fs35">let output, ctx = <br />&#160;&#160;&#160;&#160;&#160;&#160;Literate.DefaultArguments<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;( input, templateFile, output, fsharpCompiler, prefix, compilerOptions, <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lineNumbers, references, replacements, includeSource, errorHandler )<br />&#160;&#160;&#160;&#160;processMarkdown ctx input output</div>
<div class="tip" id="fs36">static member Literate.ProcessScriptFile : input:string * templateFile:string * ?output:string * ?fsharpCompiler:Assembly * ?prefix:string * ?compilerOptions:string * ?lineNumbers:bool * ?references:bool * ?replacements:(string * string) list * ?includeSource:bool * ?errorHandler:(string * obj -&gt; unit) -&gt; &#39;a<br /><br />完全名: FSharp.Literate.Literate.ProcessScriptFile<br /><em><br /><br />&#160;Process F# Script file</em></div>
<div class="tip" id="fs37">let output, ctx = <br />&#160;&#160;&#160;&#160;&#160;&#160;Literate.DefaultArguments<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;( input, templateFile, output, fsharpCompiler, prefix, compilerOptions, <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lineNumbers, references, replacements, includeSource, errorHandler )<br />&#160;&#160;&#160;&#160;processScriptFile ctx input output</div>
<div class="tip" id="fs38">static member Literate.ProcessDirectory : inputDirectory:string * templateFile:string * ?outputDirectory:string * ?fsharpCompiler:Assembly * ?prefix:string * ?compilerOptions:string * ?lineNumbers:bool * ?references:bool * ?replacements:(string * string) list * ?includeSource:bool * ?errorHandler:(string * obj -&gt; unit) -&gt; unit<br /><br />完全名: FSharp.Literate.Literate.ProcessDirectory<br /><em><br /><br />&#160;Process directory containing a mix of Markdown documents and F# Script files</em></div>
<div class="tip" id="fs39">val inputDirectory : string</div>
<div class="tip" id="fs40">val outputDirectory : string option</div>
<div class="tip" id="fs41">let _, ctx = <br />&#160;&#160;&#160;&#160;&#160;&#160;Literate.DefaultArguments<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;( &quot;&quot;, templateFile, Some &quot;&quot;, fsharpCompiler, prefix, compilerOptions, <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lineNumbers, references, replacements, includeSource, errorHandler )<br />&#160;<br />&#160;&#160;&#160;&#160;/// Recursively process all files in the directory tree<br />&#160;&#160;&#160;&#160;let rec processDirectory indir outdir = <br />&#160;&#160;&#160;&#160;&#160;&#160;// Create output directory if it does not exist<br />&#160;&#160;&#160;&#160;&#160;&#160;if Directory.Exists(outdir) |&gt; not then<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;try Directory.CreateDirectory(outdir) |&gt; ignore <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;with _ -&gt; failwithf &quot;Cannot create directory &#39;%s&#39;&quot; outdir<br /><br />&#160;&#160;&#160;&#160;&#160;&#160;let fsx = [ for f in Directory.GetFiles(indir, &quot;*.fsx&quot;) -&gt; processScriptFile, f ]<br />&#160;&#160;&#160;&#160;&#160;&#160;let mds = [ for f in Directory.GetFiles(indir, &quot;*.md&quot;) -&gt; processMarkdown, f ]<br />&#160;&#160;&#160;&#160;&#160;&#160;for func, file in fsx @ mds do<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let name = Path.GetFileNameWithoutExtension(file)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let output = Path.Combine(outdir, name + &quot;.html&quot;)<br /><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Update only when needed<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let changeTime = File.GetLastWriteTime(file)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let generateTime = File.GetLastWriteTime(output)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if changeTime &gt; generateTime then<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printfn &quot;Generating &#39;%s.html&#39;&quot; name<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;func ctx file output<br /><br />&#160;&#160;&#160;&#160;let outputDirectory = defaultArg outputDirectory inputDirectory<br />&#160;&#160;&#160;&#160;processDirectory inputDirectory outputDirectory</div>
          
        </div>
        <div class="span3">

          <ul class="nav nav-list" id="menu">
            <li class="nav-header">DocSample</li>
            <li><a href="../index.html">Home page</a></li>
            <!--

              Here you can add links to other pages of the documentation 
              The 'divider' element creates a separator and additional
              'nav-header' can be used to add sub-headings in the menu:

              * <li class="divider"></li>
              * <li><a href="...">...</a></li>
              * <li class="nav-header">Sub-heading</li>

            -->
          </ul>
        </div>
      </div>
    </div>
    <a href="https://github.com/Nobuhisa"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>
  </body>
  </html>